#!/usr/bin/env python3
"""
Module to generate the template for lesson notes customized to Morning Star School.
Supports LaTeX math expressions converted to Word equations using SymPy.
"""

import os
import re
import logging
import warnings
import xml.sax.saxutils as saxutils
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.table import WD_CELL_VERTICAL_ALIGNMENT
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.enum.section import WD_ORIENT
from docx.oxml.ns import qn, nsmap
from docx.oxml import OxmlElement
from markdown2 import markdown
from bs4 import BeautifulSoup
from sympy.parsing.latex import parse_latex
from sympy.printing.mathml import mathml
from lxml import etree

# Suppress deprecated style_id warning from python-docx
warnings.filterwarnings("ignore", category=UserWarning, module="docx.styles.styles")

# Configure logging
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

def set_cell_text(cell, text, bold=False, font_size=12, align='center'):
    """
    Helper to insert styled text into a cell.
    """
    cell.vertical_alignment = WD_CELL_VERTICAL_ALIGNMENT.CENTER
    p = cell.paragraphs[0]
    p.alignment = getattr(WD_ALIGN_PARAGRAPH, align.upper())
    run = p.add_run(str(text))
    run.font.size = Pt(font_size)
    run.font.name = 'Times New Roman'
    run.bold = bold
    run._element.rPr.rFonts.set(qn('w:eastAsia'), 'Times New Roman')

def sanitize_latex(latex: str) -> str:
    """
    Sanitize LaTeX input to remove XML-incompatible characters and control characters.

    Args:
        latex: Raw LaTeX string.

    Returns:
        str: Sanitized LaTeX string.
    """
    latex = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', '', latex)
    latex = saxutils.escape(latex)
    return latex

def mathml_to_omath(mathml_str: str, inline: bool = False) -> OxmlElement:
    """
    Convert MathML to OOXML math element (m:oMath or m:oMathPara).

    Args:
        mathml_str: MathML string generated by SymPy.
        inline: If True, create m:oMath (inline); if False, create m:oMathPara (display).

    Returns:
        OxmlElement: OOXML math element.
    """
    logger.debug(f"Converting MathML to OOXML: {mathml_str[:100]}...")
    try:
        if inline:
            omath = OxmlElement('m:oMath')
        else:
            omath_para = OxmlElement('m:oMathPara')
            omath = OxmlElement('m:oMath')
            omath_para.append(omath)

        parser = etree.XMLParser(recover=True)
        mathml_tree = etree.fromstring(mathml_str, parser=parser)

        def convert_element(node, parent_omath):
            if node.tag == '{http://www.w3.org/1998/Math/MathML}mfrac':
                frac = OxmlElement('m:f')
                f_pr = OxmlElement('m:fPr')
                frac.append(f_pr)
                num = OxmlElement('m:num')
                denom = OxmlElement('m:den')
                for i, child in enumerate(node):
                    if i == 0:
                        convert_element(child, num)
                    elif i == 1:
                        convert_element(child, denom)
                frac.append(num)
                frac.append(denom)
                parent_omath.append(frac)
            elif node.tag == '{http://www.w3.org/1998/Math/MathML}msup':
                sup = OxmlElement('m:sSup')
                ssup_pr = OxmlElement('m:sSupPr')
                sup.append(ssup_pr)
                base = OxmlElement('m:e')
                sup_script = OxmlElement('m:sup')
                for i, child in enumerate(node):
                    if i == 0:
                        convert_element(child, base)
                    elif i == 1:
                        convert_element(child, sup_script)
                sup.append(base)
                sup.append(sup_script)
                parent_omath.append(sup)
            elif node.tag in ('{http://www.w3.org/1998/Math/MathML}mi', '{http://www.w3.org/1998/Math/MathML}mn', '{http://www.w3.org/1998/Math/MathML}mo', '{http://www.w3.org/1998/Math/MathML}mtext'):
                run = OxmlElement('m:r')
                t = OxmlElement('m:t')
                t.text = node.text if node.text else ''
                run.append(t)
                parent_omath.append(run)
            else:
                for child in node:
                    convert_element(child, parent_omath)

        convert_element(mathml_tree, omath)
        logger.debug("MathML conversion successful")
        return omath if inline else omath_para
    except Exception as e:
        logger.error(f"Failed to convert MathML to OOXML: {mathml_str[:100]}..., error: {e}")
        run = OxmlElement('m:r')
        t = OxmlElement('m:t')
        t.text = 'Error rendering equation'
        omath = OxmlElement('m:oMath')
        omath.append(run)
        return omath if inline else OxmlElement('m:oMathPara').append(omath)

def create_omath_element(latex: str, inline: bool = False) -> OxmlElement:
    """
    Convert a LaTeX expression to an OOXML math element using SymPy.

    Args:
        latex: LaTeX expression (e.g., r'\text{Exterior Angle} = \frac{360^\circ}{n}').
        inline: If True, create m:oMath (inline); if False, create m:oMathPara (display).

    Returns:
        OxmlElement: OOXML math element.
    """
    logger.debug(f"Processing LaTeX: {latex}")
    try:
        latex_clean = sanitize_latex(latex.strip().replace(r'\(', '').replace(r'\)', '').replace(r'\[', '').replace(r'\]', ''))
        expr = parse_latex(latex_clean)
        mathml_str = mathml(expr, printer=None)
        omath_element = mathml_to_omath(mathml_str, inline=inline)
        logger.debug(f"Successfully created OOXML element for LaTeX: {latex}")
        return omath_element
    except Exception as e:
        logger.error(f"Failed to convert LaTeX to OOXML: {latex}, error: {str(e)}")
        run = OxmlElement('m:r')
        t = OxmlElement('m:t')
        t.text = latex_clean if latex_clean else 'Invalid LaTeX'
        omath = OxmlElement('m:oMath')
        omath.append(run)
        if inline:
            logger.debug("Returning fallback inline math element")
            return omath
        omath_para = OxmlElement('m:oMathPara')
        omath_para.append(omath)
        logger.debug("Returning fallback display math element")
        return omath_para

def apply_html_styles(cell, html_content, paragraph=None):
    """
    Parse HTML content and apply equivalent Word styles to a cell or paragraph.
    """
    soup = BeautifulSoup(html_content, 'html.parser')
    if paragraph is None:
        paragraph = cell.paragraphs[0]
        paragraph.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

    def process_node(node, p, run_bold=False, run_italic=False, run_underline=False):
        if node.name == 'p':
            new_p = cell.add_paragraph()
            new_p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
            for child in node.children:
                process_node(child, new_p, run_bold, run_italic, run_underline)
        elif node.name:
            new_bold = run_bold or node.name in ('strong', 'b')
            new_italic = run_italic or node.name in ('em', 'i')
            new_underline = run_underline or node.name == 'u'
            for child in node.children:
                process_node(child, p, new_bold, new_italic, new_underline)
        elif node.string and node.string.strip():
            run = p.add_run(node.string.strip())
            run.font.name = 'Times New Roman'
            run.font.size = Pt(14)
            run.bold = run_bold
            run.italic = run_italic
            run.underline = run_underline

    for child in soup.find_all(recursive=False):
        if child.name == 'p':
            new_p = cell.add_paragraph()
            new_p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
            for subchild in child.children:
                process_node(subchild, new_p)
        else:
            process_node(child, paragraph)

def add_markdown_to_paragraph(cell, text):
    """
    Parse Markdown or HTML text, convert LaTeX math to Word equations, and apply Word styling.

    Args:
        cell: Table cell to add content to.
        text: Input text containing Markdown, HTML, or LaTeX.
    """
    logger.debug(f"Processing text: {text[:100]}...")
    # Improved regex to match LaTeX, handling multi-line and nested expressions
    inline_latex = re.findall(r'\\\((?:[^\\]|\\[^)])*?\\\)', text, re.DOTALL)
    display_latex = re.findall(r'\\\[.*?\\\]', text, re.DOTALL)

    if inline_latex or display_latex:
        logger.debug(f"Found LaTeX: Inline={len(inline_latex)}, Display={len(display_latex)}")
        # Split text around LaTeX expressions
        pattern = r'(\\\(.*?\\\)|\\\[.*?\\\])'
        segments = re.split(pattern, text, flags=re.DOTALL)
        paragraph = cell.paragraphs[0]
        paragraph.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY

        for segment in segments:
            if not segment:
                continue
            logger.debug(f"Processing segment: {segment[:50]}...")
            if segment.startswith(r'\(') and segment.endswith(r'\)'):
                # Inline LaTeX
                omath = create_omath_element(segment, inline=True)
                paragraph._element.append(omath)
                logger.debug(f"Added inline equation: {segment}")
            elif segment.startswith(r'\[') and segment.endswith(r'\]'):
                # Display LaTeX
                omath_para = create_omath_element(segment, inline=False)
                paragraph._element.append(omath_para)
                logger.debug(f"Added display equation: {segment}")
            else:
                # Process Markdown/HTML
                if re.search(r'<[a-zA-Z]+>', segment):
                    apply_html_styles(cell, segment, paragraph)
                    logger.debug("Processed HTML segment")
                else:
                    html = markdown(segment, extras=["fenced-code-blocks"])
                    apply_html_styles(cell, html, paragraph)
                    logger.debug("Processed Markdown segment")
    else:
        logger.debug("No LaTeX found, processing as Markdown/HTML")
        if re.search(r'<[a-zA-Z]+>', text):
            apply_html_styles(cell, text)
        else:
            html = markdown(text, extras=["fenced-code-blocks"])
            apply_html_styles(cell, html)

def add_bulleted_list(cell, items):
    """
    Add a bulleted list to a cell, with each item supporting HTML/Markdown/LaTeX styling.
    """
    for item in items:
        p = cell.add_paragraph(style='List Bullet')
        p.alignment = WD_ALIGN_PARAGRAPH.LEFT
        temp_doc = Document()
        temp_cell = temp_doc.add_table(1, 1).rows[0].cells[0]
        add_markdown_to_paragraph(temp_cell, item.strip())
        for temp_para in temp_cell.paragraphs:
            for element in temp_para._element:
                if element.tag.endswith('}oMath') or element.tag.endswith('}oMathPara'):
                    p._element.append(element)
                else:
                    for run in temp_para.runs:
                        new_run = p.add_run(run.text)
                        new_run.font.name = run.font.name
                        new_run.font.size = run.font.size
                        new_run.bold = run.bold
                        new_run.italic = run.italic
                        new_run.underline = run.underline

def add_paragraphs_to_cell(cell, text):
    """
    Split text into paragraphs and add to a cell with HTML/Markdown/LaTeX styling.
    """
    if re.search(r'<p>', text, re.IGNORECASE):
        add_markdown_to_paragraph(cell, text)
    else:
        paragraphs = [p.strip() for p in text.split('\n\n') if p.strip()]
        for i, para in enumerate(paragraphs):
            p = cell.paragraphs[0] if i == 0 else cell.add_paragraph()
            p.alignment = WD_ALIGN_PARAGRAPH.JUSTIFY
            add_markdown_to_paragraph(cell, para)

def sanitize_filename(filename):
    """
    Sanitize filename to remove invalid characters.
    """
    return re.sub(r'[<>:"/\\|?*]', '_', filename)

def create_lesson_notes_template(data=None, logo_path='./assets/images/MostarLogo.png'):
    """
    Creates a lesson notes template for Morning Star School and returns the file path.
    """
    if data is None:
        data = {}
    
    doc = Document()

    # Set the page to landscape orientation
    section = doc.sections[-1]
    section.orientation = WD_ORIENT.LANDSCAPE
    section.page_width, section.page_height = section.page_height, section.page_width

    # Estimate usable page width (subtract ~2 inches total for 1-inch margins)
    PAGE_WIDTH = section.page_width - Inches(2)

    # Header with School Name and Logo
    try:
        paragraph = doc.add_paragraph()
        run = paragraph.add_run("THE MORNING STAR SCHOOL LTD.\n")
        run.bold = True
        run.font.size = Pt(20)
        run.font.name = 'Times New Roman'

        run.add_break()
        if os.path.exists(logo_path):
            run.add_picture(logo_path, width=Inches(1.5))
        else:
            logger.warning(f"Logo file not found at {logo_path}")
        run.add_break()
        run.add_text("WEEKLY LESSON PLAN")
        paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
    except Exception as e:
        logger.error(f"Error adding header: {e}")
        raise

    doc.add_paragraph()  # Add spacing

    # Table structure
    rows_data = [
        ("WEEK ENDING", data.get("WEEK_ENDING", "")),
        ("DAYS", " ".join(data.get("DAYS", [])) if isinstance(data.get("DAYS"), list) else data.get("DAYS", "")),
        ("DURATION", data.get("DURATION", "")),
        ("SUBJECT", data.get("SUBJECT", "")),
        ("STRAND", data.get("STRAND", "")),
        ("SUBSTRAND", data.get("SUBSTRAND", "")),
        ("CLASS", data.get("CLASS", "")),
        ("CLASS SIZE", " ".join(f"{cls}({size})" for cls, size in data.get("CLASS_SIZE", {}).items())),
        ("CONTENT STANDARD", data.get("CONTENT_STANDARD", [])),
        ("LEARNING INDICATOR(S)", data.get("LEARNING_INDICATORS", [])),
        ("PERFORMANCE INDICATOR(S)", data.get("PERFORMANCE_INDICATORS", [])),
        ("TEACHING/LEARNING RESOURCES", data.get("TEACHING_LEARNING_RESOURCES", [])),
        ("CORE COMPETENCIES", data.get("CORE_COMPETENCIES", [])),
        ("KEY WORDS", data.get("KEY_WORDS", [])),
        ("R.P.K", data.get("R.P.K", "")),
    ]

    table = doc.add_table(rows=len(rows_data), cols=2)
    table.style = 'Table Grid'
    table.autofit = False

    col1_width = PAGE_WIDTH * 0.3
    col2_width = PAGE_WIDTH * 0.7

    for i, (label, value) in enumerate(rows_data):
        cell1, cell2 = table.rows[i].cells
        cell1.width = col1_width
        cell2.width = col2_width
        set_cell_text(cell1, label, bold=True, font_size=16)
        if isinstance(value, list):
            add_bulleted_list(cell2, value)
        else:
            add_markdown_to_paragraph(cell2, value)

    doc.add_paragraph()

    # The Content of the Lesson Notes
    phase_headers = ["PHASE 1: STARTER", "PHASE 2: MAIN", "PHASE 3: REFLECTION"]
    phase_data = (
        data.get("PHASE_1", {}).get("STARTER", ""),
        data.get("PHASE_2", {}).get("MAIN", ""),
        data.get("PHASE_3", {}).get("REFLECTION", "")
    )

    table2 = doc.add_table(rows=2, cols=3)
    table2.style = 'Table Grid'
    table2.autofit = False

    col1_width = PAGE_WIDTH * 0.2
    col2_width = PAGE_WIDTH * 0.6
    col3_width = PAGE_WIDTH * 0.2

    for i, row_data in enumerate([phase_headers, phase_data]):
        cell1, cell2, cell3 = table2.rows[i].cells
        cell1.width = col1_width
        cell2.width = col2_width
        cell3.width = col3_width
        if i == 0:  # Headers
            set_cell_text(cell1, row_data[0], bold=True, font_size=14, align="justify")
            set_cell_text(cell2, row_data[1], bold=True, font_size=14, align="center")
            set_cell_text(cell3, row_data[2], bold=True, font_size=14, align="center")
        else:  # Content
            add_markdown_to_paragraph(cell1, row_data[0])
            add_paragraphs_to_cell(cell2, row_data[1])
            add_markdown_to_paragraph(cell3, row_data[2])

    doc.add_paragraph()

    table3 = doc.add_table(rows=2, cols=2)
    table3.style = 'Table Grid'
    table3.autofit = False
    col1_width = PAGE_WIDTH * 0.3
    col2_width = PAGE_WIDTH * 0.7

    assessment_data = [
        ("ASSESSMENTS", ""),
        ("", f"{data.get('ASSESSMENTS', '')}\n\n\n{data.get('HOMEWORK', '')}"),
    ]

    for i, (label, content) in enumerate(assessment_data):
        cell1, cell2 = table3.rows[i].cells
        cell1.width = col1_width
        cell2.width = col2_width
        set_cell_text(cell1, label, bold=True, font_size=16)
        add_markdown_to_paragraph(cell2, content)

    # Save the document
    subject = data.get("SUBJECT", "Unknown")
    week = data.get("WEEK", "Unknown")
    cls = data.get("CLASS", "Unknown")
    filename = sanitize_filename(f"{cls}_Lesson_Notes_{subject}_WEEK_{week}.docx")
    try:
        doc.save(filename)
        file_path = os.path.abspath(filename)
        logger.info(f"Lesson notes template created successfully: {file_path}")
        return file_path
    except Exception as e:
        logger.error(f"Error saving document: {e}")
        raise

if __name__ == "__main__":
    example_data = {
        "WEEK_ENDING": "16th May, 2025",
        "DAYS": "Monday - Friday",
        "WEEK": "3",
        "DURATION": "4 periods per class",
        "SUBJECT": "Mathematics",
        "STRAND": "Strand 3: Geometry and Measurement",
        "SUBSTRAND": "Substrand 2: Angles and Polygons",
        "CLASS": "Basic Eight",
        "CLASS_SIZE": {"A": 28, "B": 28, "C": 28},
        "CONTENT_STANDARD": ["B8.3.2.1: Demonstrate understanding of properties of polygons and solve related problems"],
        "LEARNING_INDICATORS": ["B8.3.2.1.1: Identify and calculate interior and exterior angles of polygons"],
        "PERFORMANCE_INDICATORS": [
            "Calculate the sum of interior angles of various polygons.",
            "Determine the measure of an exterior angle of a regular polygon.",
            "Solve real-life problems involving angles in polygons."
        ],
        "TEACHING_LEARNING_RESOURCES": ["Charts showing different polygons", "Markers", "Whiteboard", "Protractor"],
        "CORE_COMPETENCIES": ["Creativity", "Critical Thinking", "Collaboration"],
        "KEY_WORDS": ["Polygon", "Interior Angle", "Exterior Angle", "Regular Polygon", "Irregular Polygon", "Sum of Angles", "Vertex"],
        "R.P.K": "Learners have basic knowledge of triangles and quadrilaterals and can identify polygons with up to six sides.",
        "PHASE_1": {
            "STARTER": "Begin the lesson by asking students to name different shapes they see around them and classify them as polygons or non-polygons. Discuss what makes a shape a polygon and introduce the concept of angles in these shapes."
        },
        "PHASE_2": {
            "MAIN": "The objective of this lesson is to understand and calculate the angles in various polygons, which are essential components in both mathematics and everyday life. We will explore both interior and exterior angles and apply these concepts to solve problems. \n\n1. **Lesson Objective:** By the end of the lesson, learners should be able to calculate the sum of interior angles and the measure of exterior angles in polygons. \n\n2. **Introduction:** Consider the Ghanaian Kente cloth, which often features geometric patterns. These patterns include various polygons, such as triangles, squares, and hexagons. Understanding the properties of these shapes helps in creating precise and beautiful designs. Similarly, the architecture of traditional Ghanaian buildings often incorporates polygonal shapes for aesthetic and structural purposes. \n\n3. **Step-by-Step Explanation:** \n   - **Interior Angles:** The sum of the interior angles of a polygon with \\( n \\) sides can be calculated using the formula: \n     \\[ (n - 2) \\times 180^\\circ \\] \n     For example, a pentagon (5 sides) has an interior angle sum of: \n     \\[ (5 - 2) \\times 180^\\circ = 540^\\circ \\] \n   - **Exterior Angles:** The sum of the exterior angles of any polygon is always \\( 360^\\circ \\). For a regular polygon, each exterior angle can be calculated by dividing \\( 360^\\circ \\) by the number of sides \\( n \\): \n     \\[ \\text{Exterior Angle} = \\frac{360^\\circ}{n} \\] \n     For a hexagon, each exterior angle is: \n     \\[ \\frac{360^\\circ}{6} = 60^\\circ \\] \n\n4. **Guided Practice:** \n   - **Activity 1:** Use the protractor to measure angles of different polygons drawn on the whiteboard. Collaboratively calculate the interior angle sum for each shape. \n   - **Activity 2:** In groups, create and decorate a polygon cut-out (triangle, square, pentagon) and label each angle. Calculate both interior and exterior angles. \n\n5. **Independent Practice:** \n   - Problem 1: Calculate the sum of interior angles of a nonagon (9 sides). \n   - Problem 2: Determine the measure of one interior angle of a regular octagon. \n   - Problem 3: A polygon has an exterior angle of \\( 45^\\circ \\). How many sides does this polygon have?"
        },
        "PHASE_3": {
            "REFLECTION": "Review the key concepts of interior and exterior angles in polygons. Ask students to share how they might use these calculations in real-life scenarios, such as designing patterns or constructing objects. Clarify any mistakes and emphasize the importance of accuracy in calculations. Discuss how understanding these concepts can aid in solving more complex geometrical problems."
        },
        "ASSESSMENTS": "Observe learners as they engage in activities, ensuring they collaborate effectively and understand the concepts. Provide immediate feedback and address any misconceptions during the lesson. Use a short quiz at the end to assess their understanding of interior and exterior angles in polygons.",
        "HOMEWORK": "Complete the following problems: 1) Calculate the sum of the interior angles of a decagon (10 sides). 2) If each exterior angle of a regular polygon is \\( 30^\\circ \\), how many sides does the polygon have? Ensure to show all your workings."
    }
    create_lesson_notes_template(example_data)